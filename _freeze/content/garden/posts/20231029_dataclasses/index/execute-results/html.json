{
  "hash": "a057316c497572aa66fba80cce5483bf",
  "result": {
    "markdown": "---\ntitle: Object Oriented Programming (OOP) with Datasets\nsubtitle: Showing the idea of using OOP (i.e. S3) to define and manipulate datasets in a standard way\nimage: \"images/classobjects.png\"\ndate: \"10/29/2023\"\ndraft: false\npage-layout: article\ntoc: true\ncomments:\n  utterances:\n    repo: ngiangre/ngiangre.github.io\n---\n\n\nDatasets can come in many different shapes and sizes, such as a number of rows and columns. But what if I need to interface with datasets in a specific but standard way? I can create a class for this.\n\nLet's say I have two datasets that I want to represent in a standard way. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- datasets::airquality\nd2 <- datasets::anscombe\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 |> head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Ozone Solar.R Wind Temp Month Day\n1    41     190  7.4   67     5   1\n2    36     118  8.0   72     5   2\n3    12     149 12.6   74     5   3\n4    18     313 11.5   62     5   4\n5    NA      NA 14.3   56     5   5\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nd2 |> head(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  x1 x2 x3 x4   y1   y2    y3   y4\n1 10 10 10  8 8.04 9.14  7.46 6.58\n2  8  8  8  8 6.95 8.14  6.77 5.76\n3 13 13 13  8 7.58 8.74 12.74 7.71\n4  9  9  9  8 8.81 8.77  7.11 8.84\n5 11 11 11  8 8.33 9.26  7.81 8.47\n```\n:::\n:::\n\n\nThese two example datasets are actually classes already (i.e. S3 classes), and are data.frames (which are also classes).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::otype(d1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"\n```\n:::\n\n```{.r .cell-code}\nsloop::s3_class(d1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsloop::otype(d2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"S3\"\n```\n:::\n\n```{.r .cell-code}\nsloop::s3_class(d2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"data.frame\"\n```\n:::\n:::\n\n\nSo what's the issue if they are already classes? I actually want to know the number of rows and columns including the name of the data. That's easy to derive, but think 'what if they weren't?' - having information available would be handy. The class would then be a simple interface to that information. To that end, I would make an object with class 'my_data' and the below attributes. This generates a fancy list using `structure`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(\n    list(\n        data.frame = NULL,\n        name = NULL,\n        ncols = function(x)ncol(x),\n        nrows = function(x)nrow(x)\n    ),\n    class = \"my_data\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$data.frame\nNULL\n\n$name\nNULL\n\n$ncols\nfunction(x)ncol(x)\n\n$nrows\nfunction(x)nrow(x)\n\nattr(,\"class\")\n[1] \"my_data\"\n```\n:::\n:::\n\n\nTo create objects of this class, I would create a constructor. The constructor would just be a function taking in the input and wrapping it in my new class (a fancy list):\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_data <- function(dat,name = NULL){\n    stopifnot(is.data.frame(dat))\n    structure(\n    list(\n        data.frame = dat,\n        name = name,\n        ncols = ncol(dat),\n        nrows = nrow(dat)\n    ),\n    class = \"my_data\"\n    )\n}\n\nd1_data <- my_data(d1,\"d1\")\nd2_data <- my_data(d2,\"d2\")\n\nd1_data$name\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"d1\"\n```\n:::\n\n```{.r .cell-code}\nd2_data$ncols\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 8\n```\n:::\n:::\n\n\nThis seems sort of useful, but what would be more useful is showing me the information I want in the way I want. To do this, I make a method for this class:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow.my_data <- function(x){\n    cat(x$name,\"\\n\")\n    cat(\"Rows: \",x$nrow,\"\\n\")\n    cat(\"Columns: \",x$ncol)\n}\n\nshow <- function(x){\n    UseMethod(\"show\")\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nshow(d1_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nd1 \nRows:  153 \nColumns:  6\n```\n:::\n\n```{.r .cell-code}\nshow(d2_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nd2 \nRows:  11 \nColumns:  8\n```\n:::\n:::\n\n\nI defined a `show` method that is _specific_ to objects of my class. Pretty nifty. This ability gets niftier as the complexity of the attributes and the operations on objects of this class increases. \n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}