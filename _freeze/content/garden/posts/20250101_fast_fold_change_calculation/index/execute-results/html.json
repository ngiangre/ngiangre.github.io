{
  "hash": "4a3ff737c43a643eaf37c3bc9e7653b0",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Computing group differences fast\"\nsubtitle: Initial generalization how to comput summaries withinand betwee variables\nimage: \"images/algebra.jpeg\"\ndate: \"01/01/2025\"\ndraft: false\npage-layout: article\ntoc: true\ntoc_float: true\ncomments:\n  utterances:\n    repo: ngiangre/ngiangre.github.io\n---\n\n\n\n::: column-page\n\nI had a thought for computing the fold change of the average of two distributions. Below is my attempt to try out something - a {data.table} and a {dplyr} implementation. The {data.table} approach doesn't scale well compared to the {dplyr} approach so I must have did something wrong with the syntax. Using the {dtplyr} package actually helps in this case with translating to the right syntax for the speed ups afforded by {data.table}. However the {dplyr} function actually outperforms the function using {dtplyr}. However, the {dplyr} implentation is still pretty slow at the scale I ideally want to target...need to think this implentation through...\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncreate_dataset <- function(n=1e6,n_tests = 2,n_groups = 3){\n    stopifnot(is.numeric(n_groups) & n_groups>0)\n    stopifnot(is.numeric(n_tests) & n_tests>0)\n    eg <- expand.grid(1:n_groups,1:n_tests)\n    var1 <- eg[['Var1']]\n    var2 <- eg[['Var2']]\n    purrr::map2_dfr(\n        var1,\n        var2,\n    function(grp,name){\n        data.table::data.table(\n            \"group\" = grp,\n            \"name\" = name,\n            \"value\" = rgamma(n,sample(1:10,1),sample(1:10,1))\n            )\n        })\n}\ndat <- create_dataset(n=10,n_tests = 1,n_groups = 2)\ndim(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20  3\n```\n\n\n:::\n\n```{.r .cell-code}\nhead(dat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   group name    value\n1:     1    1 7.214747\n2:     1    1 5.734305\n3:     1    1 3.698168\n4:     1    1 2.566807\n5:     1    1 3.387825\n6:     1    1 4.297761\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\ncompute_fc_dt <- function(df, measurement_col, group_cols, value_col = \"value\") {\n    if (!requireNamespace(\"data.table\", quietly = TRUE)) {\n        stop(\"The 'data.table' package is required but not installed.\")\n    }\n    \n    # Convert to data.table and validate input\n    dt <- as.data.table(df)\n    stopifnot(value_col %in% colnames(dt),\n              all(group_cols %in% colnames(dt)),\n              measurement_col %in% colnames(dt))\n    \n    # Ensure the value column is numeric and remove NA values\n    dt <- dt[!is.na(get(value_col))]\n    dt[[value_col]] <- as.numeric(dt[[value_col]])\n    \n    # Compute fold changes for all group column combinations\n    final_result <- purrr::map_dfr(unique(dt[[measurement_col]]),function(measure){\n        dt_measure <- dt[get(measurement_col) == measure]\n        \n        # Compute fold changes for each group column\n        purrr::map_dfr(group_cols,function(group_col){\n            levels <- unique(dt_measure[[group_col]])\n            combos <- combn(levels, 2, simplify = FALSE)\n            \n            # Calculate fold changes for each pair of levels\n            purrr::map_dfr(combos,function(combo){\n                group1 <- combo[1]\n                group2 <- combo[2]\n                \n                # Compute means for each group\n                mean1 <- dt_measure[get(group_col) == group1, mean(get(value_col), na.rm = TRUE)]\n                mean2 <- dt_measure[get(group_col) == group2, mean(get(value_col), na.rm = TRUE)]\n                \n                # Calculate fold change and avoid division by zero\n                fold_change <- mean1 / mean2\n                if (fold_change < 1) fold_change <- 1 / fold_change\n                \n                # Append the result to the list\n                data.table(\n                    measurement = measure,\n                    group_col = group_col,\n                    group1 = group1,\n                    group2 = group2,\n                    AVAL = fold_change\n                )\n            })\n        })\n    })\n    \n    # Combine results and add analysis column\n    final_result[['PARAM']] = \"fold_change\"\n    return(final_result)\n}\ncompute_fc_dplyr <- function(df, measurement_col, group_cols, value_col = \"value\") {\n    if (!requireNamespace(\"data.table\", quietly = TRUE)) {\n        stop(\"The 'data.table' package is required but not installed.\")\n    }\n    \n    # Convert to data.table and validate input\n    dt <- tibble::as_tibble(df)\n    stopifnot(value_col %in% colnames(dt),\n              all(group_cols %in% colnames(dt)),\n              measurement_col %in% colnames(dt))\n    \n    # Ensure the value column is numeric and remove NA values\n    dt <- \n        dt |> \n        dplyr::filter(!is.na(.data[[value_col]])) |> \n        dplyr::mutate(\n            dplyr::across(dplyr::all_of(value_col), as.numeric)\n        )\n    \n    # Compute fold changes\n    result <- \n        unique(dt[[measurement_col]]) |> \n        purrr::map_dfr(function(measure) {\n            dt_measure <- \n                dt |> \n                dplyr::filter(.data[[measurement_col]] == measure)\n            \n            group_cols |>\n                purrr::map_dfr(function(group_col) {\n                    dt_measure |> \n                        dplyr::summarise(\n                            mean_value = mean(.data[[value_col]], na.rm = TRUE), \n                            .by = dplyr::all_of(group_col)\n                        ) |> \n                        dplyr::summarise(\n                            AVAL = mean_value[1] / mean_value[2],\n                            group_value1 = .data[[group_col]][1], \n                            group_value2 = .data[[group_col]][2],\n                            group_column = group_col,\n                            !!measurement_col := measure\n                        )\n                })\n        }) |> \n        dplyr::mutate(\n            PARAM = \"fold_change\"\n        ) |> \n        dplyr::relocate(\n            dplyr::any_of(c(\n                \"group_column\",measurement_col,\n                \"group_value1\",\"group_value2\",\n                \"PARAM\",\"AVAL\"\n            ))\n        )\n    \n    return(result)\n}\ncompute_fc_dtplyr <- function(df, measurement_col, group_cols, value_col = \"value\") {\n    if (!requireNamespace(\"data.table\", quietly = TRUE)) {\n        stop(\"The 'data.table' package is required but not installed.\")\n    }\n    \n    # Convert to data.table and validate input\n    stopifnot(value_col %in% colnames(df),\n              all(group_cols %in% colnames(df)),\n              measurement_col %in% colnames(df))\n    \n    # Ensure the value column is numeric and remove NA values\n    dt <- \n        df |> \n        dtplyr::lazy_dt() |> \n        dplyr::filter(!is.na(.data[[value_col]])) |> \n        dplyr::mutate(\n            dplyr::across(dplyr::all_of(value_col), as.numeric)\n        )\n    \n    # Compute fold changes\n    result <- \n        unique(df[[measurement_col]]) |> \n        purrr::map_dfr(function(measure) {\n            dt_measure <- \n                dt |> \n                dplyr::filter(.data[[measurement_col]] == measure)\n            \n            group_cols |>\n                purrr::map_dfr(function(group_col) {\n                    dt_measure |> \n                        dplyr::summarise(\n                            mean_value = mean(.data[[value_col]], na.rm = TRUE), \n                            .by = dplyr::all_of(group_col)\n                        ) |> \n                        dplyr::summarise(\n                            AVAL = mean_value[1] / mean_value[2],\n                            group_value1 = .data[[group_col]][1], \n                            group_value2 = .data[[group_col]][2],\n                            group_column = group_col,\n                            !!measurement_col := measure\n                        ) |> \n                        dplyr::collect()\n                })\n        }) |> \n        dplyr::mutate(\n            PARAM = \"fold_change\"\n        ) |> \n        dplyr::relocate(\n            dplyr::any_of(c(\n                \"group_column\",measurement_col,\n                \"group_value1\",\"group_value2\",\n                \"PARAM\",\"AVAL\"\n            ))\n        )\n    \n    return(result)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntm <- \n    microbenchmark::microbenchmark(\n        compute_fc_dt(\n            create_dataset(n=1e3,n_tests = 1,n_groups = 10),\"name\",c(\"group\")\n        ),\n        compute_fc_dplyr(\n            create_dataset(n=1e3,n_tests = 1,n_groups = 10),\"name\",c(\"group\")\n        ),\n        compute_fc_dtplyr(\n            create_dataset(n=1e3,n_tests = 1,n_groups = 10),\"name\",c(\"group\")\n        ),\n        compute_fc_dplyr(\n            create_dataset(n=1e3,n_tests = 10,n_groups = 10),\"name\",c(\"group\")\n        ),\n        compute_fc_dtplyr(\n            create_dataset(n=1e3,n_tests = 10,n_groups = 10),\"name\",c(\"group\")\n        ),\n        compute_fc_dplyr(\n            create_dataset(n=1e3,n_tests = 100,n_groups = 10),\"name\",c(\"group\")\n        ),\n        compute_fc_dtplyr(\n            create_dataset(n=1e3,n_tests = 100,n_groups = 10),\"name\",c(\"group\")\n        ),\n        unit = \"second\",\n        times = 30\n    )\ntm |> ggplot2::autoplot()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=1440}\n:::\n:::\n\n\n\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}